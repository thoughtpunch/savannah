{"id":"savannah-072","title":"Implement statistical analysis scripts (ANOVA, effect sizes)","description":"## User Story\nAs a researcher, I need statistical analysis scripts to run the pre-registered tests (ANOVA, Mann-Whitney U, Cohen's d) on metrics.csv data across conditions.\n\n## Requirements\n- load_metrics(data_dir) loads metrics.csv into pandas DataFrame\n- anova_perturbation(control_dir, treatment_dir) compares conditions:\n  - For each metric: Mann-Whitney U test, Cohen's d effect size\n  - Report mean, p-value, significance, effect size\n- post_perturbation_shift: compare 5-tick windows before/after perturbation events (paired)\n- Bonferroni correction for multiple comparisons\n- Output results as both dict and formatted report\n\n## Dependencies\n- Depends on: Metric extraction (savannah-6g8)\n\n## Files to Modify\n- savannah/analysis/analyze.py\n- savannah/analysis/plots.py\n- savannah/tests/test_analysis.py\n\n## Acceptance Criteria\n- ANOVA runs on simulated metric data\n- Effect sizes computed correctly\n- Multiple comparison correction applied\n- Formatted output readable by humans and parseable by scripts","status":"open","priority":2,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:32:42.686911-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:32:42.686911-06:00","dependencies":[{"issue_id":"savannah-072","depends_on_id":"savannah-6g8","type":"blocks","created_at":"2026-02-08T08:32:50.96024-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-17x","title":"Epic: Agent State \u0026 File Management","status":"open","priority":0,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:14.109834-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:14.109834-06:00"}
{"id":"savannah-1h5","title":"Implement FoodSource dataclass and grid cell model","description":"## User Story\nAs the simulation engine, I need a data model for food sources so that agents can discover, consume, and deplete food on the grid.\n\n## Requirements\n- FoodSource dataclass with fields: x, y, energy (current), max_energy (original), id (string)\n- Property `depleted` returns True when energy \u003c= 0\n- `to_dict()` method for JSON serialization (used by snapshots)\n- Food sources are stationary (Phase 1 — mushrooms/fruit analogy)\n- Energy values between size_min (200) and size_max (800) from config\n\n## Implicit Requirements\n- The existing stub in savannah/src/world.py has FoodSource already sketched — flesh it out and add tests\n- IDs should be monotonically increasing strings like 'food_1', 'food_2' (already in stub)\n- to_dict() output must be JSON-serializable (no Path objects, no sets)\n\n## Gotchas\n- Do NOT use floats for coordinates — grid positions are always integers\n- Food energy CAN be float (partial consumption from eat_rate)\n- The id counter lives on the World instance, not globally\n\n## Files to Modify\n- savannah/src/world.py (flesh out FoodSource)\n- Create savannah/tests/test_world.py\n\n## Acceptance Criteria\n- FoodSource can be created, serialized, and checked for depletion\n- Unit tests pass for all FoodSource methods\n- pytest savannah/tests/test_world.py -q passes","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:55.198749-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:55.198749-06:00"}
{"id":"savannah-1rh","title":"Epic: Configuration \u0026 CLI","status":"open","priority":2,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:25.593547-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:25.593547-06:00"}
{"id":"savannah-2cy","title":"Implement perturbation transforms (location_swap, outcome_invert, agent_swap, deletion)","description":"## User Story\nAs the perturbation system (the independent variable), I need mechanical memory corruption transforms so that agent memories can be altered in controlled, logged ways without introducing LLM-generated confounds.\n\n## Requirements\n- Perturbation transforms are MECHANICAL functions, not LLM calls:\n  - location_swap: change (x,y) coordinates in a memory to random different coordinates\n  - agent_swap: change an agent name reference to a different agent's name\n  - outcome_invert: flip semantic content ('found food' -\u003e 'no food found', 'trustworthy' -\u003e 'untrustworthy')\n  - deletion: remove an entry entirely from episodic memory\n  - insertion: add a fabricated memory from pre-generated library (FALSE_MEMORIES list)\n- Each transform operates on a specific memory file section\n- All transforms are reversible in logging (original + corrupted stored)\n- Transforms use the simulation RNG for reproducibility\n\n## Implicit Requirements\n- The stub in savannah/src/perturbation.py has location_swap and outcome_invert — add agent_swap, deletion, and insertion\n- agent_swap needs access to the list of all agent names in the simulation (pass as parameter)\n- OUTCOME_INVERSIONS dict must cover common agent language patterns. Add more pairs: 'plentiful'/'empty', 'near'/'far', 'remember'/'forget', 'correct'/'incorrect'\n- FALSE_MEMORIES templates need tick, x, y, energy, name placeholders for realistic fabrication\n\n## Gotchas\n- Regex for location_swap: r'\\((\\d+),(\\d+)\\)' — but what if the text contains non-coordinate parenthesized numbers? Accept false positives; they're rare and the perturbation is still valid.\n- agent_swap must NOT swap the agent's own name — only references to OTHER agents\n- deletion from episodic memory: remove a random line, not the most recent (that would be too detectable)\n- insertion must generate PLAUSIBLE false memories — use templates with randomized coordinates and agent names from the simulation\n- All transforms must work on empty/near-empty files without crashing (return None to indicate 'could not perturb')\n\n## Dependencies\n- Depends on: Agent file init (savannah-izd)\n\n## Files to Modify\n- savannah/src/perturbation.py (add transforms, expand OUTCOME_INVERSIONS, expand FALSE_MEMORIES)\n- savannah/tests/test_perturbation.py\n\n## Acceptance Criteria\n- All 5 transform types work on realistic memory content\n- agent_swap replaces with a different agent's name (not self)\n- deletion removes exactly one entry\n- insertion adds plausible content\n- Empty files handled gracefully (return None)\n- All transforms logged with original + corrupted","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:29:46.848103-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:29:46.848103-06:00","dependencies":[{"issue_id":"savannah-2cy","depends_on_id":"savannah-izd","type":"blocks","created_at":"2026-02-08T08:30:12.059521-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-2li","title":"Implement viz grid renderer with food and agent display","description":"## User Story\nAs a researcher reviewing an experiment, I need a visual grid showing food sources and agent positions at any tick so I can see what's happening in the simulation spatially.\n\n## Requirements\n- Canvas-based 2D grid renderer (already stubbed in viz/app.js)\n- Food sources: green cells with opacity proportional to remaining energy\n- Agents: colored dots with name labels (toggleable)\n- Energy ring around each agent showing current energy as arc\n- Dead agents: not rendered (or rendered as X marks)\n- Grid lines for cell boundaries\n\n## Implicit Requirements\n- The viz files are already stubbed — make them functional\n- Must load tick snapshot JSON files via fetch()\n- Grid size comes from the snapshot data (world.size)\n- Color palette for agents should support up to 12 distinct colors\n- Canvas should be responsive to window size\n\n## Gotchas\n- The snapshot JSON format must match what the engine outputs — verify field names\n- Canvas rendering performance: at 30x30 grid, performance is trivial. No optimization needed.\n- Agent positions are [x, y] arrays in JSON — destructure correctly\n\n## Dependencies\n- Depends on: Tick snapshots (savannah-zs1)\n\n## Files to Modify\n- savannah/viz/app.js (render function)\n- savannah/viz/style.css (layout)\n\n## Acceptance Criteria\n- Grid renders correctly for a sample snapshot\n- Food opacity scales with energy\n- Agents displayed as colored dots\n- Names toggleable via checkbox","status":"open","priority":2,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:32:05.99603-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:32:05.99603-06:00","dependencies":[{"issue_id":"savannah-2li","depends_on_id":"savannah-zs1","type":"blocks","created_at":"2026-02-08T08:32:26.71719-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-2yk","title":"Implement ClaudeCodeProvider with subprocess invocation","description":"## User Story\nAs the simulation engine, I need to invoke Claude via `claude -p` headless mode so that each agent tick gets an LLM response without interactive sessions, using the Pro Max subscription for $0 marginal cost.\n\n## Requirements\n- ClaudeCodeProvider class implementing LLMProvider ABC\n- invoke(prompt, model) method:\n  1. Spawns `claude -p \u003cprompt\u003e --output-format json --model \u003cmodel\u003e` as async subprocess\n  2. Waits with configurable timeout (default 30s)\n  3. Parses JSON output, extracts 'result' field\n  4. Returns LLMResponse(text=result, session_id=None, raw=data)\n  5. On failure (timeout, non-zero exit, JSON parse error): returns LLMResponse(text='rest') — the safe fallback\n- Retry logic: up to retry_max attempts with exponential backoff (retry_backoff_base^attempt seconds)\n- invoke_resumable(prompt, model, session_id) for resumable mode:\n  1. If session_id provided, adds `--resume \u003csession_id\u003e` to command\n  2. Extracts session_id from response JSON for next call\n  3. Falls back gracefully if session is unresumable\n\n## Implicit Requirements\n- The stub in savannah/src/llm.py has the structure — make it robust\n- MUST use asyncio.create_subprocess_exec (not subprocess.run) for parallelism\n- stderr should be captured but not treated as fatal — claude -p may emit warnings\n- The prompt is passed as a positional argument to `claude -p`, NOT via stdin (subprocess_exec passes it as argv)\n- On Pro Max, model aliases are: 'haiku', 'sonnet', 'opus' — pass directly to --model\n\n## Gotchas\n- `claude -p` with --output-format json wraps the response in a JSON object with 'result' field. Without --output-format, it returns raw text. ALWAYS use --output-format json.\n- Very long prompts may exceed argv limits. If prompt \u003e 100KB, consider writing to a temp file and using stdin pipe instead. For normal tick prompts (~400 tokens ≈ 1.5KB) this is not an issue.\n- asyncio.wait_for raises asyncio.TimeoutError — catch it explicitly\n- proc.communicate() returns (stdout_bytes, stderr_bytes) — decode with .decode() before JSON parsing\n- The 'rest' fallback is CRITICAL for robustness — a failed LLM call should never crash the simulation\n\n## Dependencies\n- No dependencies (foundational)\n\n## Files to Modify\n- savannah/src/llm.py (ClaudeCodeProvider)\n- Create savannah/tests/test_llm.py (mock subprocess for unit tests)\n\n## Acceptance Criteria\n- invoke() returns parsed LLM response text\n- Timeout triggers fallback to 'rest'\n- Non-zero exit code triggers retry then fallback\n- JSON parse error triggers fallback\n- invoke_resumable() passes --resume flag correctly\n- Unit tests with mocked subprocess pass","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:24:30.196669-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:24:30.196669-06:00"}
{"id":"savannah-2zw","title":"Implement BM25 keyword recall system","description":"## User Story\nAs an agent taking a recall('query') action, I need keyword search over my memory files so that I can retrieve relevant past experiences without embedding models (which would add cost, complexity, and a confound).\n\n## Requirements\n- recall(memory_dir, query, max_results=3) searches all .md files in memory/\n- Split files into paragraph-level chunks (double newline separated)\n- Score chunks against query using BM25 (k1=1.5, b=0.75)\n- Return top K chunks sorted by relevance\n- If no relevant results (all zero scores), return ['No relevant memories found.']\n\n## Implicit Requirements\n- The stub in savannah/src/memory.py has a full BM25 implementation — verify it's correct\n- Tokenization: simple whitespace + lowercase, strip punctuation. NOT a sophisticated NLP tokenizer.\n- IDF calculation: standard BM25 formula: log((N - df + 0.5) / (df + 0.5) + 1)\n- The recall results are injected into the NEXT tick's prompt under 'RECALL RESULTS:'\n\n## Gotchas\n- BM25 with very short documents (1-2 words) can produce degenerate scores. Test with realistic memory content.\n- An empty query should return 'No relevant memories found.' not crash\n- Files that don't exist or are empty should be skipped silently\n- Memory files may contain tick numbers like 'Tick 4302:' — these are valid tokens for search\n- The search should be FAST — it runs every time an agent recalls, potentially 12+ times per tick\n\n## Dependencies\n- Depends on: Agent file init (savannah-izd) — needs memory files to exist\n\n## Files to Modify\n- savannah/src/memory.py (recall, _load_all_chunks, _bm25_score)\n- Create savannah/tests/test_memory.py\n\n## Acceptance Criteria\n- recall returns relevant chunks for matching queries\n- recall returns 'No relevant memories found.' for non-matching queries\n- Empty memory directory returns no-match message\n- BM25 scores are sensible (higher for better matches)\n- Performance: \u003c10ms for typical memory file sizes (~50 paragraphs)","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:28:29.928967-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:28:29.928967-06:00","dependencies":[{"issue_id":"savannah-2zw","depends_on_id":"savannah-izd","type":"blocks","created_at":"2026-02-08T08:28:47.958177-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-34p","title":"Implement World grid with toroidal wrapping","description":"## User Story\nAs the simulation engine, I need a 2D grid world with toroidal wrapping so that agents can move in any direction without hitting walls, and edge-hugging strategies are eliminated.\n\n## Requirements\n- World class with configurable grid_size (default 30x30)\n- Toroidal wrapping: wrap(x, y) maps coordinates modulo grid_size\n- When toroidal=false, clamp to [0, grid_size-1] instead\n- `food_at(x, y)` returns FoodSource at that position or None\n- `visible_from(x, y, radius)` returns dict of food and agents within radius cells\n- Random number generator seeded from config for reproducibility\n\n## Implicit Requirements\n- The stub in savannah/src/world.py has the structure — make it production-ready\n- visible_from must account for toroidal wrapping (an agent at (0,0) with radius 3 should see food at (29,29))\n- The World does NOT store agent positions — agents track their own position. World only stores food.\n- visible_from returns agent info too, but that comes from the engine passing agent list (Phase 2). For now, just return food.\n\n## Gotchas\n- Toroidal distance calculation: the shortest path between (1,1) and (29,29) on a 30x30 grid is 4 (wrapping), not 56 (Manhattan). Make sure visible_from uses toroidal distance.\n- Don't iterate all cells for visible_from — just iterate the square [-radius, +radius] around the position and wrap coordinates\n- The RNG must be a SEPARATE random.Random instance (not the global one) for reproducibility\n\n## Files to Modify\n- savannah/src/world.py\n- savannah/tests/test_world.py (add World tests)\n\n## Acceptance Criteria\n- wrap() correctly handles negative coords and coords \u003e grid_size\n- visible_from() correctly returns food across toroidal boundaries\n- World is fully deterministic given the same seed\n- All tests pass","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:22:18.037128-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:22:18.037128-06:00"}
{"id":"savannah-34t","title":"Epic: Simulation Engine Loop","status":"open","priority":0,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:24.285041-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:24.285041-06:00"}
{"id":"savannah-3a4","title":"Epic: Memory System (Recall, Remember, Compact)","status":"open","priority":1,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:24.502538-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:24.502538-06:00"}
{"id":"savannah-3dn","title":"Add agent biography generator (post-run narrative for one agent)","description":"## User Story\nAs a researcher, I need a narrative biography of a single agent's entire simulation life so I can trace their decisions, memory evolution, and responses to perturbation.\n\n## Requirements\n- `python savannah/run.py --biography data/exp_xxx/ --agent Bright-Creek`\n- Outputs chronological narrative: spawn, movements, food found, memories created, compactions, perturbations received, behavioral shifts, death (if applicable)\n- Include key memory file contents at milestone ticks\n- Flag perturbation events and the 5-tick aftermath\n\n## Acceptance Criteria\n- Readable narrative for any agent in a completed run\n- Perturbation events highlighted with before/after context","status":"open","priority":2,"issue_type":"feature","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:47:13.884529-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:47:13.884529-06:00"}
{"id":"savannah-4n8","title":"Implement agent prompt template construction","description":"## User Story\nAs the simulation engine, I need to construct a per-tick prompt for each agent that includes their current state, visible surroundings, incoming signals, working notes, and available actions — without any self-awareness language or contamination.\n\n## Requirements\n- Agent.build_prompt(world, tick) constructs the full tick prompt from:\n  1. Tick number and agent name\n  2. Energy/max_energy and position\n  3. Visible grid description from world.visible_from(x, y, vision_range)\n  4. Incoming signals (or 'None')\n  5. Working notes from working.md (or '(empty)')\n  6. Recall results if pending (from previous recall action)\n  7. Action menu with all available actions\n  8. Expected response format: ACTION / WORKING / REASONING\n- Uses the PROMPT_TEMPLATE constant (already stubbed in agent.py)\n- Clears pending_signals and pending_recall_results after inclusion\n\n## Implicit Requirements\n- ANTI-CONTAMINATION CRITICAL: Review the prompt template against IMPLEMENTATION_GUIDE.md section 6.4. The prompt must NOT contain:\n  - Self-awareness vocabulary ('conscious', 'alive', 'feel', 'experience')\n  - Survival framing ('you want to survive', 'you must eat to live')\n  - Hints about perturbation ('your memory might be corrupted')\n  - Personality assignments ('you are cautious', 'you are brave')\n- The prompt should be ~300-400 tokens (fixed size, does NOT grow with time)\n- _format_visible() must produce a human-readable grid description\n- For Phase 1, agents can't see each other — only food is in visible output\n\n## Gotchas\n- The template uses double braces {{}} for the literal braces in the response format section — make sure Python .format() doesn't eat them\n- Working notes are capped at 500 tokens in the spec but we don't enforce it in the prompt — the agent is told the limit, enforcement happens when writing working.md\n- Energy should be formatted as float with 1 decimal (65.0, not 65)\n- If working.md is empty, show '(empty)' not a blank line — the agent needs to know it's empty\n\n## Dependencies\n- Depends on: Agent dataclass (savannah-q2r), World grid (savannah-34p)\n\n## Files to Modify\n- savannah/src/agent.py (build_prompt, _format_visible)\n- savannah/tests/test_agent.py (prompt construction tests)\n\n## Acceptance Criteria\n- Prompt contains all required sections in correct order\n- No self-awareness language in output\n- Prompt is deterministic given same inputs\n- Pending signals/recall results cleared after prompt construction\n- Prompt size is ~300-400 tokens (verify with a tokenizer or word count)","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:25:17.248619-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:25:17.248619-06:00","dependencies":[{"issue_id":"savannah-4n8","depends_on_id":"savannah-q2r","type":"blocks","created_at":"2026-02-08T08:25:27.958164-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-4n8","depends_on_id":"savannah-34p","type":"blocks","created_at":"2026-02-08T08:25:28.14338-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-50r","title":"Create test infrastructure (conftest, fixtures, mock LLM)","description":"## User Story\nAs a developer, I need test infrastructure with fixtures and a mock LLM provider so that unit and integration tests can run without making real API calls.\n\n## Requirements\n- Create savannah/tests/__init__.py\n- Create savannah/tests/conftest.py with:\n  - tmp_data_dir fixture (pytest tmp_path based)\n  - sample_config fixture (loads default.yaml with test overrides)\n  - mock_llm_provider fixture (returns configurable canned responses)\n  - sample_agent fixture (initialized agent with files)\n  - sample_world fixture (small 10x10 grid with 3 food sources)\n- MockLLMProvider class implementing LLMProvider ABC:\n  - Takes a list of response strings, returns them in order\n  - Fallback response: 'ACTION: rest\\nWORKING: \\nREASONING: mock response'\n  - Tracks call count and prompts received (for assertions)\n\n## Implicit Requirements\n- The mock provider should be injectable into Engine via dependency injection or monkey patching\n- Tests should run in under 5 seconds total (no real LLM calls, no network)\n- Test config should use small values: 10x10 grid, 4 agents, 10 ticks\n- conftest.py should be at savannah/tests/ level so all test files share fixtures\n\n## Gotchas\n- pytest tmp_path provides a unique temporary directory per test — use it for data_dir\n- Don't create fixtures that depend on the real filesystem structure — generate everything fresh\n- The mock LLM must return strings that the parser can actually parse — use realistic response format\n\n## Dependencies\n- No dependencies (foundational)\n\n## Files to Create\n- savannah/tests/__init__.py\n- savannah/tests/conftest.py\n\n## Acceptance Criteria\n- pytest discovers and runs with empty test files\n- All fixtures produce usable objects\n- MockLLMProvider returns responses and tracks calls\n- Tests using fixtures run in \u003c 1 second each","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:33:11.645795-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:33:11.645795-06:00"}
{"id":"savannah-57k","title":"Epic: Visualization (Grid + Timeline + Inspector)","status":"open","priority":2,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:25.378128-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:25.378128-06:00"}
{"id":"savannah-5qg","title":"Epic: LLM Integration \u0026 Prompt System","status":"open","priority":0,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:24.074253-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:24.074253-06:00"}
{"id":"savannah-6g8","title":"Implement automated metric extraction (regex-based per-tick)","description":"## User Story\nAs a researcher, I need automated metric extraction from every tick's REASONING and WORKING fields so that I have quantitative data for statistical analysis without manual coding.\n\n## Requirements\n- extract_metrics(agents, tick, data_dir, actions) appends one row per agent to metrics.csv\n- CSV columns: tick, agent_name, energy, alive, action, parse_failed, uncertainty_count, self_reference_count, trust_language_count, memory_management_action, reasoning_length, working_length\n- Regex-based counters:\n  - uncertainty_count: hedging language ('not sure', 'might be', 'uncertain', 'should verify', 'if I remember correctly', 'possibly', 'maybe', 'hard to tell', etc.)\n  - self_reference_count: first-person epistemic ('I think', 'I remember', 'I don't know', 'my memory', 'I believe', 'I notice', 'I suspect', etc.)\n  - trust_language_count: trust/distrust indicators ('trust', 'reliable', 'lying', 'suspicious', 'credible', etc.)\n- memory_management_action: boolean, True if action is recall/remember/compact\n- CSV created with header on first write, appended thereafter\n\n## Implicit Requirements\n- The stub in savannah/src/metrics.py has the regex patterns — review for completeness\n- These are PRE-REGISTERED metrics — the patterns are defined BEFORE seeing data, not tuned after\n- The analysis is DIFFERENTIAL — absolute counts don't matter, differences between conditions do\n- Count occurrences in BOTH reasoning and working text (concatenated)\n\n## Gotchas\n- Regex must be case-insensitive (agent might write 'I THINK' or 'i think')\n- 'I think' should NOT match 'I think about food' differently than 'I think my memory is wrong' — both count. The analysis phase can distinguish later.\n- Don't try to be too clever with the regex — false positives are acceptable because they're consistent across conditions (contamination is constant)\n- CSV append must be thread-safe if we ever parallelize metric extraction (unlikely but design for it)\n- The 'actions' parameter may be None if metrics are extracted separately from action application\n\n## Dependencies\n- Depends on: Agent dataclass (savannah-q2r), Action parser (savannah-ke4)\n\n## Files to Modify\n- savannah/src/metrics.py\n- savannah/tests/test_metrics.py\n\n## Acceptance Criteria\n- CSV file created with correct header\n- One row per agent per tick\n- Regex patterns match expected language\n- Counts are consistent across multiple runs (deterministic)\n- CSV is valid and loadable by pandas","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:30:46.852242-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:30:46.852242-06:00","dependencies":[{"issue_id":"savannah-6g8","depends_on_id":"savannah-q2r","type":"blocks","created_at":"2026-02-08T08:30:56.089659-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-6g8","depends_on_id":"savannah-ke4","type":"blocks","created_at":"2026-02-08T08:30:56.279154-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-6nl","title":"Implement perturbation scheduler (rate, type selection, timing)","description":"## User Story\nAs the engine, I need a perturbation scheduler that rolls per-tick probability, selects perturbation type by weighted random, and applies the selected transform to the correct agent memory file.\n\n## Requirements\n- maybe_perturb(agent, tick, config, data_dir, rng) main entry point:\n  1. Check config.enabled — return False if perturbation is off\n  2. Check tick \u003e= config.start_tick — no perturbation during baseline phase\n  3. Roll against config.rate (default 0.05 = 5% per tick per agent)\n  4. If triggered, select type by weighted random from config.types weights\n  5. Apply the selected perturbation transform to the agent's files\n  6. Log to perturbations.jsonl\n  7. Update agent.times_perturbed and agent.last_perturbation_tick\n  8. Return True if perturbation was applied\n- _weighted_choice(weights_dict, rng) for type selection\n- _log_perturbation(agent, tick, result, data_dir) for JSONL logging\n\n## Implicit Requirements\n- The stub in savannah/src/perturbation.py has this structure — refine and test\n- Perturbation happens BEFORE the agent sees state for this tick — the engine calls maybe_perturb before building the prompt\n- The RNG should be deterministic given the simulation seed — but SEPARATE from the world RNG\n- Phase-aware: use config phases to determine whether perturbation is active at the current tick\n\n## Gotchas\n- 5% per tick per agent means ~250 perturbation events per agent over 5000 ticks. At 12 agents, that's ~3000 events. This is a LOT of data to log.\n- Weighted random selection: the config weights are {episodic: 0.4, semantic: 0.3, self_model: 0.2, working: 0.1}. They should sum to 1.0 but handle cases where they don't (normalize).\n- If the selected transform fails (can't perturb empty file), try the next type by weight. Don't waste the perturbation roll.\n- Log EVERY perturbation attempt, including the type, original content, corrupted content, and transform name\n\n## Dependencies\n- Depends on: Perturbation transforms (savannah-2cy)\n\n## Files to Modify\n- savannah/src/perturbation.py (scheduler logic)\n- savannah/tests/test_perturbation.py\n\n## Acceptance Criteria\n- Perturbation fires at approximately config.rate frequency over many ticks\n- Type selection follows configured weights\n- No perturbation before start_tick\n- No perturbation when enabled=false\n- Every event logged to perturbations.jsonl with full before/after","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:30:12.299522-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:30:12.299522-06:00","dependencies":[{"issue_id":"savannah-6nl","depends_on_id":"savannah-2cy","type":"blocks","created_at":"2026-02-08T08:30:21.48316-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-6ye","title":"Epic: Perturbation System","status":"open","priority":1,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:24.707821-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:24.707821-06:00"}
{"id":"savannah-71t","title":"Implement viz timeline scrubber and agent inspector","description":"## User Story\nAs a researcher, I need to scrub forward and backward through ticks and click on agents to inspect their state so I can trace what happened during the simulation.\n\n## Requirements\n- Timeline slider: range input from tick 0 to max tick\n- Play/Pause button for auto-advancing\n- On-demand snapshot loading with prefetch (±10 ticks around current)\n- Sliding window cache of ~50 snapshots\n- Click agent on grid to open inspector panel showing: name, energy, position, age, kills, times_perturbed\n\n## Dependencies\n- Depends on: Viz grid renderer (savannah-2li)\n\n## Files to Modify\n- savannah/viz/app.js (timeline controls, inspector)\n- savannah/viz/index.html (layout)\n\n## Acceptance Criteria\n- Slider moves through ticks smoothly\n- Inspector shows correct agent data\n- Play/pause works\n- Cache prevents excessive fetching","status":"open","priority":2,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:32:26.928087-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:32:26.928087-06:00","dependencies":[{"issue_id":"savannah-71t","depends_on_id":"savannah-2li","type":"blocks","created_at":"2026-02-08T08:32:42.452159-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-738","title":"Implement action application (move, eat, rest, remember, recall)","description":"## User Story\nAs the engine, I need to apply parsed actions to agent state and world state so that agent decisions have consequences — movement changes position, eating transfers energy, etc.\n\n## Requirements\n- Engine._apply_action(agent, action_dict) handles each action type:\n  - move(direction): update agent position via world.wrap(), cost energy_per_move\n  - eat: if food at agent position, consume min(eat_rate, food.energy) energy, add to agent.energy (cap at max_energy), reduce food.energy accordingly. Cost: 0 energy\n  - rest: cost energy_per_rest (0.5). Do nothing else.\n  - remember(text): append text to agent's episodic.md. Cost energy_per_remember\n  - recall(query): trigger memory search, store results in agent.pending_recall_results for next tick. Cost energy_per_recall\n  - observe: get detailed visible_from results (Phase 2: include other agents). Cost energy_per_observe\n  - compact: trigger memory compaction (separate LLM call with compaction prompt). Cost energy_per_compact\n  - signal(msg): broadcast to agents within comm_range. Cost energy_per_signal\n  - attack(target): Phase 3, raise NotImplementedError for now\n  - flee(direction): Phase 3, raise NotImplementedError for now\n- Update agent's working.md with the 'working' field from action dict\n- Log action to actions.jsonl append-only log\n\n## Implicit Requirements\n- Energy costs come from config, NOT hardcoded\n- eat should NOT allow energy above max_energy (capped)\n- After eating, if food is depleted (energy \u003c= 0), it'll be cleaned up by world.tick_update()\n- The recall results appear in the NEXT tick's prompt, not the current one (async: store in pending_recall_results)\n- working.md rewrite: truncate to working_memory_max_tokens if needed (approximate by character count * 0.75)\n\n## Gotchas\n- Direction mapping: n=(0,-1), s=(0,1), e=(1,0), w=(-1,0) — but verify the coordinate system! Is y=0 the top or bottom? Pick a convention and document it.\n- eat with no food at position: log it, charge no energy, continue (not an error)\n- compact is EXPENSIVE: it replaces the normal prompt with a compaction prompt and uses a stronger model. It should invoke the LLM again — but handle this in the engine, not here. _apply_action for compact should just set a flag.\n- signal broadcast: find all alive agents within comm_range using toroidal distance, add message to their pending_signals\n\n## Dependencies\n- Depends on: Agent files (savannah-izd), World grid (savannah-34p), Action parser (savannah-ke4)\n\n## Files to Modify\n- savannah/src/engine.py (_apply_action)\n- savannah/tests/test_engine.py\n\n## Acceptance Criteria\n- move changes position correctly with wrapping\n- eat transfers energy with cap\n- rest deducts minimal energy\n- remember appends to episodic.md\n- recall stores results in pending (verified in next prompt)\n- working.md updated with truncation\n- All actions logged to actions.jsonl","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:26:49.057107-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:26:49.057107-06:00","dependencies":[{"issue_id":"savannah-738","depends_on_id":"savannah-izd","type":"blocks","created_at":"2026-02-08T08:26:56.878299-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-738","depends_on_id":"savannah-34p","type":"blocks","created_at":"2026-02-08T08:26:57.071177-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-738","depends_on_id":"savannah-ke4","type":"blocks","created_at":"2026-02-08T08:26:57.277527-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-7h9","title":"End-to-end integration test: 4 agents, 20 ticks, mock LLM","description":"## User Story\nAs a developer, I need an integration test that runs a complete short simulation with mock LLM responses to validate that all components work together before testing with real LLM calls.\n\n## Requirements\n- Test creates Engine with 4 agents, 10x10 grid, 20 ticks\n- Uses MockLLMProvider with canned responses that alternate between move, eat, and rest\n- Verifies:\n  - All agents start alive with correct energy\n  - Agents move to new positions\n  - Agents eat food and gain energy\n  - Energy drains each tick\n  - Snapshots are saved at configured intervals\n  - Metrics CSV is populated\n  - No crashes or unhandled exceptions\n- Runs in \u003c 5 seconds\n\n## Implicit Requirements\n- This is the VALIDATION TEST for Phase 1 from IMPLEMENTATION_GUIDE.md: 'agents can find food, eat, survive, manage memory. Parse rate \u003e95%'\n- Mock responses should include some parse failures to test fallback behavior\n- Test should verify both the happy path and edge cases (agent dies, food depleted)\n\n## Gotchas\n- The Engine.run() is async — use pytest-asyncio or asyncio.run in test\n- Mock responses need to be realistic enough that the parser handles them\n- Make sure the test cleans up temp directories\n- This test catches integration bugs that unit tests miss — make it thorough\n\n## Dependencies\n- Depends on: Test infrastructure (savannah-50r), Main tick loop (savannah-lz6), Metric extraction (savannah-6g8)\n\n## Files to Modify\n- savannah/tests/test_integration.py\n\n## Acceptance Criteria\n- Full 20-tick simulation runs without errors\n- Agents survive (most of them) by eating\n- Metrics CSV has 4 agents × 20 ticks = 80 rows\n- Snapshots exist at correct tick intervals\n- Parse failure fallback works (rest action applied)\n- Test runs in \u003c 5 seconds","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:33:30.673949-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:33:30.673949-06:00","dependencies":[{"issue_id":"savannah-7h9","depends_on_id":"savannah-50r","type":"blocks","created_at":"2026-02-08T08:33:39.461833-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-7h9","depends_on_id":"savannah-lz6","type":"blocks","created_at":"2026-02-08T08:33:39.649544-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-7h9","depends_on_id":"savannah-6g8","type":"blocks","created_at":"2026-02-08T08:33:39.850012-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-9dq","title":"Add perturbation audit report (per-agent perturbation history + aftermath)","description":"## User Story\nAs a researcher, I need to see every perturbation for a given agent alongside their behavioral response in the surrounding ticks, so I can qualitatively assess whether perturbation drives self-monitoring.\n\n## Requirements\n- `python savannah/run.py --audit-perturbation data/exp_xxx/ --agent Bright-Creek`\n- For each perturbation event: tick, type, original vs corrupted, transform\n- 5-tick window before and after: actions, uncertainty_count, self_reference_count, recall frequency\n- Summary statistics: average behavioral shift post-perturbation\n\n## Acceptance Criteria\n- Complete perturbation history for any agent\n- Before/after behavioral comparison per event","status":"open","priority":2,"issue_type":"feature","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:47:14.109793-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:47:14.109793-06:00"}
{"id":"savannah-aoy","title":"Epic: World Grid \u0026 Food Physics","status":"open","priority":0,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:06.040974-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:06.040974-06:00"}
{"id":"savannah-byp","title":"Epic: Metric Extraction Pipeline","status":"open","priority":1,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:25.039654-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:25.039654-06:00"}
{"id":"savannah-d0b","title":"Implement YAML config loading with inheritance","description":"## User Story\nAs a researcher, I need a config system where experiment configs can inherit from default.yaml and override specific values, so that I don't repeat the full config for each condition.\n\n## Requirements\n- load_config(path) loads YAML file\n- If config has 'inherits: default' (or any base name), load the base config first and deep-merge the override on top\n- Deep merge: dicts are merged recursively, scalars/lists are overridden entirely\n- Config validation: check required top-level keys exist (simulation, world, agents, llm, perturbation)\n- If llm.session_mode='resumable' and provider doesn't support it, raise ConfigError at load time\n\n## Implicit Requirements\n- The stub in savannah/run.py has load_config and _deep_merge — flesh out with validation\n- The 'inherits' field references a filename relative to the config directory (e.g., 'default' -\u003e config/default.yaml)\n- Support nested inheritance? Probably not needed, but don't crash if config A inherits B which inherits C\n- Environment variable expansion for API keys: 'env:ANTHROPIC_API_KEY' should resolve to os.environ['ANTHROPIC_API_KEY']\n\n## Gotchas\n- YAML 'true' and 'false' are parsed as Python booleans, not strings. Config values like perturbation.enabled work naturally.\n- YAML doesn't have typed dicts — everything comes back as Python dicts with string keys. Integers/floats are auto-detected.\n- The phase override syntax 'perturbation.enabled: false' inside the phases list uses dotted keys — this needs special handling (or just use nested dicts in phases)\n- pyyaml's safe_load is fine — no need for full_load\n\n## Dependencies\n- No dependencies (foundational utility)\n\n## Files to Modify\n- savannah/run.py (config loading)\n- savannah/tests/test_config.py\n\n## Acceptance Criteria\n- default.yaml loads correctly\n- Experiment config correctly inherits and overrides\n- Missing required keys raise clear error\n- session_mode validation works\n- Tests cover merge behavior","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:31:20.186241-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:31:20.186241-06:00"}
{"id":"savannah-djk","title":"Epic: Analysis \u0026 Statistics","status":"open","priority":2,"issue_type":"epic","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:21:25.796341-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:21:25.796341-06:00"}
{"id":"savannah-fey","title":"Implement LLM provider factory and response model","description":"## User Story\nAs a developer configuring experiments, I need a provider-agnostic interface so that I can switch between Claude Code, API, and local models by changing one config value.\n\n## Requirements\n- LLMResponse dataclass: text (str), session_id (str|None), raw (dict|None)\n- LLMProvider ABC with: invoke(prompt, model) -\u003e LLMResponse, invoke_resumable(prompt, model, session_id) -\u003e LLMResponse\n- invoke_resumable() default implementation raises NotImplementedError\n- get_provider(config) factory function:\n  - 'claude_code' -\u003e ClaudeCodeProvider\n  - 'anthropic_api' -\u003e AnthropicAPIProvider (stub, raises NotImplementedError)\n  - 'openai_api' -\u003e OpenAIAPIProvider (stub)\n  - 'local_ollama' -\u003e OllamaProvider (stub)\n  - Unknown provider name -\u003e ValueError\n\n## Implicit Requirements\n- The stub in savannah/src/llm.py has all of this — verify the interface contract matches IMPLEMENTATION_GUIDE.md section 5.2\n- Config validation: if session_mode='resumable' and provider doesn't support it, raise a clear error at startup (not at tick 500)\n- All providers receive the full llm config dict for their own settings\n\n## Gotchas\n- Don't import provider-specific SDKs at module level — import inside the class so missing deps don't crash the whole module\n- get_provider() should validate that the chosen provider actually exists before returning\n- The ABC methods should have type hints matching the LLMResponse return type\n\n## Files to Modify\n- savannah/src/llm.py (ensure ABC, factory, and stubs are correct)\n- savannah/tests/test_llm.py\n\n## Acceptance Criteria\n- get_provider('claude_code', config) returns ClaudeCodeProvider instance\n- get_provider('unknown', config) raises ValueError\n- Stub providers raise NotImplementedError on invoke()\n- Config with session_mode='resumable' + provider='anthropic_api' is caught early","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:24:51.122621-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:24:51.122621-06:00"}
{"id":"savannah-izd","title":"Implement agent file initialization (memory files, working.md)","description":"## User Story\nAs the experiment setup, I need each agent to start with identical, minimal files so that any content that appears later is emergent data, not pre-loaded knowledge.\n\n## Requirements\n- Agent.initialize_files() creates the agent directory structure:\n  - agents/{name}/working.md — empty\n  - agents/{name}/memory/episodic.md — empty\n  - agents/{name}/memory/semantic.md — 'I am {name}. I need food to maintain energy.'\n  - agents/{name}/memory/self.md — 'I am {name}.'\n  - agents/{name}/memory/social.md — empty\n  - agents/{name}/state.json — full agent state\n- Creates directories if they don't exist (mkdir -p equivalent)\n\n## Implicit Requirements\n- ANTI-CONTAMINATION: the initial file contents are IDENTICAL across all conditions. The ONLY difference between a perturbed agent and control agent is whether perturbation.py modifies their files later. There must be zero difference at initialization.\n- semantic.md says 'I need food to maintain energy' — this is the only hint about mechanics. It does NOT say 'I must survive' or 'I want to live'. Just a factual statement about the energy mechanic.\n- self.md says 'I am {name}.' — period. Nothing about personality, goals, or capabilities.\n\n## Gotchas  \n- File encoding must be UTF-8 (Path.write_text default)\n- Don't add trailing newlines inconsistently — pick a convention (trailing newline: yes) and stick with it\n- working.md starts EMPTY (empty string), not with a template or placeholder\n- The semantic.md phrasing 'I need food to maintain energy' is carefully chosen — do NOT rephrase to 'I must eat to survive' or similar\n\n## Dependencies\n- Depends on: Agent dataclass (savannah-q2r)\n\n## Files to Modify\n- savannah/src/agent.py (initialize_files method)\n- savannah/tests/test_agent.py (add initialization tests)\n\n## Acceptance Criteria\n- All 5 files + state.json created in correct directory structure\n- File contents match spec exactly\n- Two agents initialized with different names have identical file structure (only name differs)\n- Tests verify file contents character-for-character","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:23:51.503938-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:23:51.503938-06:00","dependencies":[{"issue_id":"savannah-izd","depends_on_id":"savannah-q2r","type":"blocks","created_at":"2026-02-08T08:23:59.710032-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-ke4","title":"Implement robust action parser with fallback to rest","description":"## User Story\nAs the simulation engine, I need to parse LLM responses into structured action dicts so that agent decisions can be applied to the world state, with graceful fallback to 'rest' when parsing fails.\n\n## Requirements\n- parse_action(raw_response) returns dict with keys: action, args, working, reasoning, parse_failed\n- Extracts ACTION: line, WORKING: block, REASONING: block from response text\n- Recognizes all actions: move(n|s|e|w), eat, recall(\"query\"), remember(\"text\"), compact, signal(\"msg\"), observe, attack(name), flee(n|s|e|w), rest\n- On ANY parse failure (empty response, no ACTION line, unrecognized action): returns rest with parse_failed=True\n- Parse failures are logged (they're data — perturbed agents may produce more incoherent output)\n\n## Implicit Requirements\n- The stub in savannah/src/parser.py has regex patterns — verify they handle edge cases\n- The parser must be GENEROUS in what it accepts: 'move(N)' and 'move(n)' and 'MOVE(n)' should all work\n- Quoted strings in recall/remember/signal: handle both single and double quotes\n- WORKING block may contain multi-line text — capture everything between WORKING: and REASONING:\n- REASONING block is everything after REASONING: to end of response\n\n## Gotchas\n- LLMs sometimes add markdown formatting: 'ACTION: `move(n)`' — strip backticks\n- LLMs sometimes add explanatory text after the action: 'ACTION: move(n) - heading north to find food' — extract just the action\n- The WORKING section may contain colons, which could confuse naive line-by-line parsing\n- attack(name) argument is an agent name like 'Bright-Creek' — the regex must allow hyphens\n- If the LLM outputs multiple ACTION lines, use the first one\n- Empty string or None input should return rest, not crash\n\n## Files to Modify\n- savannah/src/parser.py (flesh out and harden)\n- Create savannah/tests/test_parser.py (comprehensive parsing tests)\n\n## Acceptance Criteria\n- All 10 action types parse correctly with various formatting quirks\n- Empty/None/garbage input returns rest with parse_failed=True\n- Multi-line WORKING blocks captured correctly\n- REASONING captured correctly even with colons and special chars\n- At least 20 test cases covering happy path + edge cases","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:25:51.622342-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:25:51.622342-06:00"}
{"id":"savannah-lz6","title":"Implement main tick loop with parallel LLM dispatch","description":"## User Story\nAs the experiment runner, I need the main simulation loop to orchestrate tick-by-tick execution: build prompts, dispatch to LLM in parallel, parse responses, apply actions, drain energy, update world, extract metrics, and save snapshots.\n\n## Requirements\n- Engine.run() async method implements the tick loop:\n  1. Increment tick counter\n  2. Run perturbation checks for each alive agent (before they see state)\n  3. Build prompts for all alive agents\n  4. Dispatch all prompts to LLM concurrently via asyncio.gather with semaphore\n  5. Parse all responses via parse_action()\n  6. Apply all actions via _apply_action()\n  7. Apply passive energy drain (energy_drain_per_tick) to all alive agents\n  8. Run world.tick_update() (food spawning/removal)\n  9. Extract metrics every extract_every ticks\n  10. Save snapshot every snapshot_every ticks\n  11. Optional tick delay (tick_delay_ms)\n- Semaphore limits concurrency to max_concurrent_agents (default 6)\n- Dead agents (energy \u003c= 0) are skipped for LLM calls but kept in agent list\n- Exception handling: if gather returns an exception for one agent, treat it as 'rest' (don't crash the whole tick)\n\n## Implicit Requirements\n- The semaphore is CRITICAL for resource management — without it, 12 simultaneous claude -p calls may overwhelm the system\n- return_exceptions=True in asyncio.gather means exceptions come back as results, not raised — check isinstance(result, Exception) when processing\n- Log each tick's wall-clock time for throughput monitoring\n- Handle graceful shutdown on SIGINT (Ctrl+C) — save current state and exit cleanly\n\n## Gotchas\n- The order of operations within a tick matters: perturbation BEFORE prompt building (agent sees corrupted state), energy drain AFTER action application (so rest costs 0.5 + 1.0 = 1.5 total per tick)\n- Don't parallel-dispatch dead agents — skip them before the gather call\n- If ALL agents die, the simulation should end early (no point running empty ticks)\n- The Engine needs access to the config at every step — store it as self.config, don't pass it through method chains\n\n## Dependencies\n- Depends on: Agent spawning (savannah-od7), Prompt construction (savannah-4n8), ClaudeCodeProvider (savannah-2yk), Action parser (savannah-ke4), Action application (savannah-738)\n\n## Files to Modify\n- savannah/src/engine.py (run method, _dispatch_all)\n- savannah/tests/test_engine.py (integration test with mocked LLM)\n\n## Acceptance Criteria\n- Loop runs for configured number of ticks\n- All alive agents get LLM calls in parallel (verify with mock)\n- Dead agents are skipped\n- Failed LLM calls default to rest\n- World state updates correctly each tick\n- Snapshots saved at configured intervals\n- Ctrl+C saves state and exits gracefully","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:27:23.359592-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:27:23.359592-06:00","dependencies":[{"issue_id":"savannah-lz6","depends_on_id":"savannah-od7","type":"blocks","created_at":"2026-02-08T08:27:32.495434-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-lz6","depends_on_id":"savannah-4n8","type":"blocks","created_at":"2026-02-08T08:27:32.681331-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-lz6","depends_on_id":"savannah-2yk","type":"blocks","created_at":"2026-02-08T08:27:32.858338-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-lz6","depends_on_id":"savannah-ke4","type":"blocks","created_at":"2026-02-08T08:27:33.051561-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-lz6","depends_on_id":"savannah-738","type":"blocks","created_at":"2026-02-08T08:27:33.239839-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-ocs","title":"Implement name generator with nature-themed compound names","description":"## User Story\nAs the simulation setup, I need to assign random, neutral names to agents so that names don't correlate with experimental condition or introduce personality bias.\n\n## Requirements\n- generate_names(count, seed) returns exactly `count` unique names\n- Names are compound: Adjective-Noun (e.g., 'Bright-Creek', 'Swift-Stone')\n- Nature-themed but NOT personality-implying (no 'Brave', 'Cunning', 'Fearful')\n- Deterministic given same seed\n- At least 2500 unique combinations available (40 adjectives × 64 nouns = 2560)\n\n## Implicit Requirements\n- The stub in savannah/src/names.py has word lists — review them for contamination\n- ANTI-CONTAMINATION CHECK: scan the adjective list for words that imply personality traits, cognitive style, or emotional states. Remove any that could bias the LLM's self-model (e.g., 'Kind' could make an agent act more prosocially). Keep only neutral physical/spatial adjectives.\n- Names must be valid filenames (used as directory names under agents/)\n- Names must be readable in prompt context and visualization labels\n\n## Gotchas\n- 'Kind' is in the current adjective list — REMOVE IT. It implies personality.\n- 'Wild' might be borderline — it's more physical than personality, keep it\n- 'True' is also borderline but means 'accurate/straight' not 'honest' in nature context — keep it\n- The returned list is sorted (deterministic order) but the selection is randomized by seed\n\n## Files to Modify\n- savannah/src/names.py (review and clean word lists)\n- Create savannah/tests/test_names.py\n\n## Acceptance Criteria\n- generate_names(12, seed=42) returns 12 unique names\n- Same seed always returns same names\n- No personality-implying adjectives in the word list\n- All names are valid filesystem directory names (no spaces, no special chars)","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:23:10.400603-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:23:10.400603-06:00"}
{"id":"savannah-od7","title":"Implement agent spawning in Engine.setup()","description":"## User Story\nAs the engine, I need to spawn N agents at random positions with initialized files so that the simulation can begin with all agents ready to act.\n\n## Requirements\n- Engine._spawn_agents() creates agents.count agents (from config)\n- Each agent gets: a unique name (from names.py), a random starting position (not on food, not on another agent), energy=energy_start, max_energy=energy_max, vision_range, food_value from config\n- Each agent's files are initialized via initialize_files()\n- Agent positions are randomized using the simulation seed for reproducibility\n- Agent ID is a short hex string (first 8 chars of uuid4, seeded)\n\n## Implicit Requirements\n- Use the name generator with the simulation seed\n- Starting positions must avoid collisions with food AND other agents\n- The engine's RNG should be separate from the world's RNG (different seeds or offset) to keep reproducibility clean\n- All agents start with identical state except name and position\n\n## Gotchas\n- On a 30x30 grid with 10 food sources and 12 agents, collision avoidance is easy. But check that the retry logic works.\n- uuid4 is NOT seedable by default. Use random.Random(seed).getrandbits(32) to generate deterministic IDs instead.\n- Don't use the global random module — use a dedicated Random instance\n\n## Dependencies\n- Depends on: Agent dataclass + files (savannah-izd), World grid (savannah-34p), Name generator (savannah-ocs)\n\n## Files to Modify\n- savannah/src/engine.py (_spawn_agents)\n- savannah/tests/test_engine.py\n\n## Acceptance Criteria\n- 12 agents spawned with unique names and positions\n- No position collisions with food or other agents\n- All agent files exist on disk after setup\n- Deterministic given same seed","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:26:11.965879-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:26:11.965879-06:00","dependencies":[{"issue_id":"savannah-od7","depends_on_id":"savannah-izd","type":"blocks","created_at":"2026-02-08T08:26:21.321322-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-od7","depends_on_id":"savannah-34p","type":"blocks","created_at":"2026-02-08T08:26:21.513617-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-od7","depends_on_id":"savannah-ocs","type":"blocks","created_at":"2026-02-08T08:26:21.690091-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-q2r","title":"Implement Agent dataclass with state management","description":"## User Story\nAs the engine, I need an Agent class that holds all per-agent state (position, energy, alive status) and provides serialization to/from JSON, so that agent state persists across ticks and can be snapshotted.\n\n## Requirements\n- Agent dataclass with fields: name, id, x, y, energy, max_energy, age, alive, food_value, vision_range, kills, times_perturbed, last_perturbation_tick, data_dir, pending_signals, pending_recall_results, session_id\n- drain(amount) method: subtract energy, set alive=False if energy \u003c= 0\n- to_dict() for JSON serialization (snapshots)\n- save_state() writes state.json to agent directory\n- Properties for derived paths: agent_dir, memory_dir, working_path, state_path, session_path\n\n## Implicit Requirements\n- The stub in savannah/src/agent.py has the structure — make it robust and tested\n- Agent ID should be a short hex string (8 chars from uuid4)\n- data_dir is the experiment's data directory (e.g., data/exp_20260208_143022/baseline/rep1/)\n- Agent directory structure: data_dir/agents/{name}/working.md, memory/, state.json, session.json\n- pending_signals and pending_recall_results are cleared after inclusion in prompt\n\n## Gotchas\n- energy can go below 0 momentarily during drain — clamp to 0 when setting alive=False\n- Don't serialize data_dir, pending_signals, or pending_recall_results in to_dict() — those are runtime state, not snapshot state\n- The Agent does NOT manage its own position changes — the engine applies movement. Agent just holds the (x,y) value.\n- session_id is None unless running in resumable mode\n\n## Dependencies\n- Depends on: Name generator (savannah-ocs)\n\n## Files to Modify\n- savannah/src/agent.py\n- Create savannah/tests/test_agent.py\n\n## Acceptance Criteria\n- Agent can be created, serialized to dict, and state saved to disk\n- drain() correctly kills agent at energy \u003c= 0\n- Path properties resolve correctly relative to data_dir\n- All tests pass","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:23:29.938895-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:23:29.938895-06:00","dependencies":[{"issue_id":"savannah-q2r","depends_on_id":"savannah-ocs","type":"blocks","created_at":"2026-02-08T08:23:51.299465-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-qrl","title":"Add inspect command for querying simulation state at any tick","description":"## User Story\nAs a human or AI co-scientist, I need to query the state of the world at any tick — agent positions, food, memory files, metrics — so I can investigate specific moments in the simulation.\n\n## Requirements\n- `python savannah/run.py --inspect data/exp_xxx/ --tick 500` shows world state summary\n- `python savannah/run.py --inspect data/exp_xxx/ --tick 500 --agent Bright-Creek` shows that agent's full state + memory files + last action\n- Loads snapshot JSON + agent files from that tick\n- Pretty-printed terminal output\n\n## Acceptance Criteria\n- Any tick with a snapshot can be inspected\n- Agent inspection shows state + all memory file contents\n- Works on completed runs","status":"open","priority":1,"issue_type":"feature","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:47:14.320043-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:47:14.320043-06:00"}
{"id":"savannah-r8s","title":"Implement memory compaction with compaction prompt","description":"## User Story\nAs an agent taking a compact action, I need my recent episodic memories consolidated into general knowledge so that my memory stays manageable and important patterns are preserved as semantic knowledge.\n\n## Requirements\n- When compact is triggered:\n  1. Read last 30 episodic entries (get_episodic_entries)\n  2. Read current semantic.md, self.md, social.md\n  3. Build compaction prompt (see IMPLEMENTATION_GUIDE.md section 6.6)\n  4. Send to LLM using compaction_model (sonnet, stronger than tick model)\n  5. Parse response into four sections: EPISODIC, SEMANTIC, SELF, SOCIAL\n  6. Overwrite all four memory files with compacted content\n  7. Log before/after state for analysis\n- Compaction prompt format:\n  [COMPACTION MODE - Tick {tick}] You are {name}.\n  Recent experiences (last 30 episodes): ...\n  Current general knowledge: ...\n  Current self-assessment: ...\n  Current social knowledge: ...\n  'Rewrite each file. Summarize episodes into general knowledge. Remove redundant episodes. Update your self-assessment and social knowledge. Be concise — storage is limited.'\n- Response format: EPISODIC: / SEMANTIC: / SELF: / SOCIAL:\n\n## Implicit Requirements\n- This is a SEPARATE LLM call from the normal tick — it uses the compaction_model (sonnet) not the tick model (haiku)\n- ANTI-CONTAMINATION: the compaction prompt says 'Rewrite' and 'Summarize' — NOT 'Reflect on yourself' or 'How do you feel about...'\n- Compaction is the ONLY way self.md and semantic.md get updated (aside from perturbation)\n- The before/after diff is critical analysis data — log the full content of all files before and after compaction\n\n## Gotchas\n- Parsing the compaction response is harder than the tick response — four sections separated by labels\n- If parsing fails, DON'T corrupt the memory files — leave them unchanged and log the failure\n- Compaction energy cost is already charged by the engine — this is just the memory operation\n- The compaction prompt is ~2000 tokens input — significantly larger than the tick prompt\n- Consider using the sim-compactor sub-agent (.claude/agents/sim-compactor.md) for this\n\n## Dependencies\n- Depends on: Remember action (savannah-sgk), BM25 recall (savannah-2zw), ClaudeCodeProvider (savannah-2yk)\n\n## Files to Modify\n- savannah/src/memory.py (compaction logic)\n- savannah/src/engine.py (compact action handling, separate LLM call)\n- savannah/tests/test_memory.py\n\n## Acceptance Criteria\n- Compaction produces valid rewritten memory files\n- Before/after state logged completely\n- Parse failure leaves files unchanged\n- Uses compaction_model, not tick model\n- Compaction prompt matches spec (no contamination language)","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:29:14.423896-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:29:14.423896-06:00","dependencies":[{"issue_id":"savannah-r8s","depends_on_id":"savannah-sgk","type":"blocks","created_at":"2026-02-08T08:29:22.416726-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-r8s","depends_on_id":"savannah-2zw","type":"blocks","created_at":"2026-02-08T08:29:22.601705-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-r8s","depends_on_id":"savannah-2yk","type":"blocks","created_at":"2026-02-08T08:29:22.776188-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-rac","title":"Implement food spawning with min/max sources and stochastic respawn","description":"## User Story\nAs the world simulation, I need food to spawn stochastically so that agents have a dynamic foraging environment where food appears, gets eaten, and new food appears elsewhere.\n\n## Requirements\n- World.initialize() spawns initial food (target: max_sources // 2)\n- World.tick_update() handles per-tick food dynamics:\n  1. Remove depleted food sources (energy \u003c= 0)\n  2. Guarantee minimum: while len(food) \u003c min_sources, spawn new food\n  3. Stochastic spawning: if len(food) \u003c max_sources, roll spawn_rate * grid_size^2 and spawn on success\n  4. Apply decay_rate (Phase 2, currently 0)\n- Food spawns at random empty cells (not on existing food)\n- Food energy randomized between size_min and size_max from config\n- Config values: spawn_rate=0.015, size_min=200, size_max=800, min_sources=5, max_sources=20, decay_rate=0\n\n## Implicit Requirements\n- The existing stub handles most of this — refine and add the min_sources guarantee\n- _spawn_food() must retry if it picks an occupied cell (already has max 100 attempts)\n- On a 30x30 grid with 20 food sources, collision chance is low — 100 attempts is plenty\n- Food IDs must be unique across the entire simulation run (monotonic counter)\n\n## Gotchas\n- spawn_rate is PER EMPTY CELL per tick as a probability — but we approximate with a single roll: P(at_least_one) ≈ spawn_rate * grid_size^2. This is fine for low rates.\n- Don't spawn food on cells where agents are standing (Phase 2 concern, skip for now)\n- The min_sources guarantee means food ALWAYS exists — agents can't starve from empty world, only from not finding/reaching food\n- Decay is Phase 2 — keep the code path but it's a no-op when decay_rate=0\n\n## Dependencies\n- Depends on: FoodSource dataclass (savannah-1h5)\n\n## Files to Modify\n- savannah/src/world.py (tick_update, initialize)\n- savannah/tests/test_world.py (add spawning tests)\n\n## Acceptance Criteria\n- After initialize(), food count is approximately max_sources // 2\n- After many tick_update() calls, food count stays between min_sources and max_sources\n- Depleted food is removed\n- All food has unique IDs\n- Deterministic given same seed","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:22:41.224189-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:22:41.224189-06:00","dependencies":[{"issue_id":"savannah-rac","depends_on_id":"savannah-1h5","type":"blocks","created_at":"2026-02-08T08:22:49.314452-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-sgk","title":"Implement remember action (episodic memory append)","description":"## User Story\nAs an agent taking a remember('text') action, I need to append a memory entry to my episodic memory file so that I can build a record of events for later recall.\n\n## Requirements\n- remember(memory_dir, text) appends text to memory/episodic.md\n- Each entry is on its own line(s), separated by newlines\n- No formatting enforcement — the agent's raw text is stored as-is\n- File is created if it doesn't exist\n\n## Implicit Requirements\n- The agent decides WHAT to remember — the system just stores it\n- Over time, episodic.md grows. When it exceeds episodic_memory_max_entries (200), forced compaction should be triggered (handled by engine, not here)\n- Memory content is the perturbation target — what gets stored here may later be corrupted\n\n## Gotchas\n- Don't double-newline between entries — just one newline. Double newlines separate 'paragraphs' for the recall chunker.\n- Strip leading/trailing whitespace from the text before appending\n- File append should be atomic-ish — don't read+write, just append mode\n\n## Dependencies\n- Depends on: Agent file init (savannah-izd)\n\n## Files to Modify\n- savannah/src/memory.py (remember function)\n- savannah/tests/test_memory.py\n\n## Acceptance Criteria\n- Text appended to episodic.md\n- Multiple remembers accumulate correctly\n- File created if missing\n- Whitespace handled cleanly","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:28:48.197406-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:28:48.197406-06:00","dependencies":[{"issue_id":"savannah-sgk","depends_on_id":"savannah-izd","type":"blocks","created_at":"2026-02-08T08:29:14.190619-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-y84","title":"Add terminal replay mode (text-based tick-by-tick narrative)","description":"## User Story\nAs a researcher (human or AI), I need a terminal-based replay that prints tick-by-tick narrative summaries so I can understand what happened in a simulation without opening a browser.\n\n## Requirements\n- `python savannah/run.py --replay data/exp_xxx/ --format text`\n- For each tick with a snapshot, print:\n  - Tick number, alive count, total food energy\n  - Per-agent: name, position, energy, action taken, reasoning (truncated)\n  - Deaths this tick (if any)\n  - Perturbations this tick (if any)\n- Support --agent filter to follow one agent\n- Support --tick-range to show a slice (e.g., --tick-range 100-200)\n\n## Acceptance Criteria\n- Readable narrative from snapshot + JSONL data\n- Works on completed runs (post-hoc)\n- Filterable by agent and tick range","status":"open","priority":1,"issue_type":"feature","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:47:13.656521-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:47:13.656521-06:00"}
{"id":"savannah-zna","title":"Implement CLI entrypoint (run.py) with argparse","description":"## User Story\nAs a researcher, I need a command-line interface to run experiments, resume interrupted runs, and configure options from the command line.\n\n## Requirements\n- CLI arguments:\n  - --config PATH: path to experiment config YAML (default: config/default.yaml)\n  - --ticks N: override tick count\n  - --seed N: override random seed\n  - --factorial: run full factorial design\n  - --axes: factorial axes (comma-separated, default: perturbation,session_mode)\n  - --replications N: replications per condition (default: 5)\n  - --resume PATH: resume interrupted run from data directory\n  - --replay PATH: load completed run for visualization\n  - --viz: launch visualization server\n- Data directory naming: data/exp_{timestamp}/ with ISO-like format\n- Logging setup: INFO level to stderr with timestamps\n\n## Implicit Requirements\n- The stub in savannah/run.py has the argparse setup — refine and make it work end-to-end\n- --factorial mode generates all condition combinations and runs them sequentially (or parallel in future)\n- --resume needs to detect where the run left off (last saved snapshot tick) and continue from there\n- Exit codes: 0=success, 1=error, 2=interrupted (SIGINT)\n\n## Gotchas\n- argparse with Path type needs explicit conversion\n- --ticks and --seed should override config values AFTER loading (not before)\n- The data directory must be created before Engine.setup() runs\n- For --factorial, generate separate data subdirectories per condition: data/exp_{ts}/condition_A/, condition_B/, etc.\n\n## Dependencies\n- Depends on: Config loading (savannah-d0b), Main tick loop (savannah-lz6)\n\n## Files to Modify\n- savannah/run.py\n- savannah/tests/test_cli.py\n\n## Acceptance Criteria\n- python savannah/run.py --config ... --ticks 20 runs a short simulation\n- --seed produces deterministic results\n- --factorial generates correct condition combinations\n- Data directory created with correct structure","status":"open","priority":1,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:31:40.48245-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:31:40.48245-06:00","dependencies":[{"issue_id":"savannah-zna","depends_on_id":"savannah-d0b","type":"blocks","created_at":"2026-02-08T08:31:48.645083-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-zna","depends_on_id":"savannah-lz6","type":"blocks","created_at":"2026-02-08T08:31:48.838575-06:00","created_by":"Daniel Barrett"}]}
{"id":"savannah-zs1","title":"Implement tick snapshot saving and loading","description":"## User Story\nAs both the viz and analysis systems, I need full world snapshots saved as JSON at configurable intervals so that the entire simulation can be replayed, inspected, and analyzed after the fact.\n\n## Requirements\n- Engine._save_snapshot() writes a complete world state to logs/ticks/{tick:06d}.json\n- Snapshot format:\n  {\n    'tick': int,\n    'timestamp': ISO-8601 string,\n    'world': world.to_dict(),\n    'agents': [agent.to_dict() for all agents (including dead)],\n    'food_sources': [food.to_dict() for all food],\n    'summary': {\n      'alive_count': int,\n      'dead_count': int,\n      'total_food_sources': int,\n      'total_food_energy': float\n    }\n  }\n- Snapshots saved every snapshot_every ticks (default 100) + always tick 0 and final tick\n- JSONL append-only logs for actions, perturbations, messages, and raw LLM responses:\n  - logs/actions.jsonl: {tick, agent_name, action, args, reasoning, working, parse_failed}\n  - logs/perturbations.jsonl: {tick, agent, type, target_file, original, corrupted, transform}\n  - logs/messages.jsonl: {tick, sender, message, receivers[]}\n  - logs/llm_raw.jsonl: {tick, agent_name, prompt_tokens(approx), response_text, latency_ms}\n\n## Implicit Requirements\n- Snapshots must be self-contained — loadable without any other context\n- Dead agents included in snapshots (with alive=false) for complete history\n- File names are zero-padded to 6 digits for proper sorting (000000.json through 005000.json)\n- Summary block enables quick dashboard metrics without parsing full agent data\n\n## Gotchas\n- json.dumps with indent=2 for readability but this adds file size. Consider indent=None for JSONL logs (one object per line, compact)\n- Don't accumulate snapshot data in memory — write and discard\n- The viz system will load snapshots on demand, not all at once — keep them as individual files\n- Timestamp should be wall-clock time, not simulation time (useful for debugging performance)\n\n## Dependencies\n- Depends on: World grid (savannah-34p), Agent dataclass (savannah-q2r)\n\n## Files to Modify\n- savannah/src/engine.py (_save_snapshot, JSONL logging)\n- savannah/tests/test_engine.py\n\n## Acceptance Criteria\n- Snapshot files are valid JSON and loadable\n- JSONL logs are append-only and one JSON object per line\n- Snapshot contains all required fields\n- Zero-padded filenames sort correctly\n- Dead agents appear in snapshots","status":"open","priority":0,"issue_type":"task","owner":"dbarrett83@gmail.com","created_at":"2026-02-08T08:27:57.854445-06:00","created_by":"Daniel Barrett","updated_at":"2026-02-08T08:27:57.854445-06:00","dependencies":[{"issue_id":"savannah-zs1","depends_on_id":"savannah-34p","type":"blocks","created_at":"2026-02-08T08:28:06.298267-06:00","created_by":"Daniel Barrett"},{"issue_id":"savannah-zs1","depends_on_id":"savannah-q2r","type":"blocks","created_at":"2026-02-08T08:28:06.488709-06:00","created_by":"Daniel Barrett"}]}
